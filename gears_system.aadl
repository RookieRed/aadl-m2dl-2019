package gears_system
public
	-- Data types
	with Base_Types;
	with Data_Model;
	Boolean renames data Base_Types::Boolean;
	Integer renames data Base_Types::Integer;
	
	-- Custom data types
	data shock_absorber
	end shock_absorber;
	data implementation shock_absorber.imp
		properties
			Data_Model::Data_Representation => enum;
			Data_Model::Enumerators => ("vol", "sol");
	end shock_absorber.imp;
	
	data handle
	end handle;
	data implementation handle.imp
		properties
			Data_Model::Data_Representation => enum;
			Data_Model::Enumerators => ("up", "down");
	end handle.imp;
	
	data switch_value
	end switch_value;
	data implementation switch_value.imp
		properties
			Data_Model::Data_Representation => enum;
			Data_Model::Enumerators => ("closed", "open");
	end switch_value.imp;

	-- Global Digital part system
	system digital_part
		features
			general_EV: out data port Boolean;
			open_EV: out data port Boolean;
			close_EV: out data port Boolean;
			rectract_EV: out data port Boolean;
			extend_EV: out data port Boolean;
			handle: in event data port handle.imp;
			switch_value: in event data port switch_value.imp;
			maneuvring: out data port Boolean;
			locked_down: out data port Boolean;
			error: out data port Boolean;
			door_closed: in event data port Boolean;
			hydrolic_presurized: in event data port Boolean;
			door_openned: in event data port Boolean;
			gear_extended: in event data port Boolean;
			gear_retracted: in event data port Boolean;
			gear_shock_absorb: in event data port shock_absorber.imp;
	end digital_part;

	system implementation digital_part.dp1
		subcomponents
			dp_mem: memory dp_RAM;
			dp_proc: processor dp_processor;
			dps: process dp_software.dps;
			mbdp: bus mem_bus;
		connections
			digital_part_dp1_new_connection: bus access dp_proc.mbus <-> mbdp;
			digital_part_dp1_new_connection2: bus access dp_mem.mbus <-> mbdp;
	end digital_part.dp1;

	process dp_software
	end dp_software;
	
	process implementation dp_software.dps
		subcomponents
			pit: thread pilote_interface_thread;
			gmt: thread gears_manager_thread.imp;
	end dp_software.dps;

	-- Thread pilote interface
	thread pilote_interface_thread
		features
			maneuvring: out event data port Boolean;
			locked_down: out event data port Boolean;
			error: out event data port Boolean;
			door_closed: in event data port Boolean;
			door_openned: in event data port Boolean;
			gear_extended: in event data port Boolean;
			gear_retracted: in event data port Boolean;
			gear_shock_absorb: in event data port shock_absorber.imp;
		properties
				Dispatch_protocol => sporadic;
				period=>10ms;
	end pilote_interface_thread;

	-- Thread Gears Manager
	thread gears_manager_thread
		features
			switch_value: in event data port switch_value.imp;
			handle: in event data port handle.imp;
			-- EV
			general_EV: out data port Boolean;
			open_EV: out data port Boolean;
			close_EV: out data port Boolean;
			rectract_EV: out data port Boolean;
			extend_EV: out data port Boolean;
			-- sensors
			hydrolic_presurized: in event data port Boolean;
			door_closed: in event data port Boolean;
			door_openned: in event data port Boolean;
			gear_extended: in event data port Boolean;
			gear_retracted: in event data port Boolean;
			gear_shock_absorb: in event data port shock_absorber.imp;
			
		properties
			Dispatch_Protocol => Sporadic;
			Period => 10ms; 
	end gears_manager_thread;
	
	thread implementation gears_manager_thread.imp
		annex behavior_specification {**
			variables
				h: handle.imp;	
				s: switch_value.imp;
				shock_abs: shock_absorber.imp;
			states
				wait_handle: initial complete state;
				locked_down_ground: complete state;
				wait_switch: complete state;
				wait_presurized: complete state;
				gear_moving: complete state;
				door_openning: complete state;
				door_closing: complete state;
				error: state;
			transitions
				wait_handle -[on dispatch handle]-> wait_switch {
					h := handle
				};
				wait_switch -[on dispatch switch_value]-> wait_presurized {
					general_EV!(true)
				};
				wait_presurized -[on dispatch hydrolic_presurized]-> door_openning {
					open_EV!(true)
				};
				door_openning -[on dispatch door_openned]-> gear_moving {
					if (h = "up") extend_EV!(true)
					else rectract_EV!(true)
					end if
				};
				gear_moving -[on dispatch gear_extended or gear_retracted]-> door_closing {
					close_EV!(true)
				};
				door_closing  -[on dispatch door_closed]-> wait_handle {
					if (h = "up") extend_EV!(false)
					else rectract_EV!(false)
					end if;
					close_EV!(false);
					general_EV!(false)
				};
		**};
	end gears_manager_thread.imp;

	-- Devices
	device pilote_interface
		features
			maneuvring: in data port Boolean;
			locked_down: in data port Boolean;
			error: in data port Boolean;
	end pilote_interface;

	device pilot_command
		features
			handle: out event data port handle.imp;
	end pilot_command;

	device analogical_switch
	end analogical_switch;

	device descret_sensor
		features
			value: out event data port;
	end descret_sensor;

	device implementation descret_sensor.door_close_sensor
	end descret_sensor.door_close_sensor;

	device implementation descret_sensor.door_open_sensor
	end descret_sensor.door_open_sensor;

	device implementation descret_sensor.gears_extend_sensor
	end descret_sensor.gears_extend_sensor;

	device implementation descret_sensor.gears_retract_sensor
	end descret_sensor.gears_retract_sensor;

	device implementation descret_sensor.gear_shock_sensor
	end descret_sensor.gear_shock_sensor;

	memory dp_RAM
		features
			mbus: requires bus access mem_bus;
	end dp_RAM;

	processor dp_processor
		features
			mbus: requires bus access mem_bus;
	end dp_processor;

	-- Buses
	bus mem_bus
	end mem_bus;

	bus hydrolic_bus
	end hydrolic_bus;

	bus dp_to_ev_bus
	end dp_to_ev_bus;

	-- Electro valves
	device electro_valve
		features
			hydrolic_in: requires bus access hydrolic_bus;
			hydrolic_out: requires bus access hydrolic_bus;
			dp_orders: in data port;
	end electro_valve;

	device implementation electro_valve.general_EV
	end electro_valve.general_EV;

	device implementation electro_valve.close_EV
	end electro_valve.close_EV;

	device implementation electro_valve.retract_EV
	end electro_valve.retract_EV;

	device implementation electro_valve.extend_EV
	end electro_valve.extend_EV;

	device implementation electro_valve.open_EV
	end electro_valve.open_EV;

	thread implementation pilote_interface_thread.pilote_interface
		subcomponents
			v: data Boolean {Data_Model::Initial_Value=>("false");};
			dc: data Boolean {Data_Model::Initial_Value=>("false");};
			ge: data Boolean {Data_Model::Initial_Value=>("false");};
			gr: data Boolean {Data_Model::Initial_Value=>("false");};
		annex behavior_specification {**
			states
				s0: initial complete state;
				
			transitions
				-- reveillé si gear_extended, on se met en etat locked_down
				s0-[on dispatch gear_extended]->s0 {
					gear_extended?(v);
					locked_down!(v);
					if (v) { -- on n'a qu'un seul état à la fois
						maneuvring!(false);
						error!(false)
					}
					end if
				};
				
				-- reveillé si porte ou roue non-verouillées, on se met en état maneuvring
				s0-[on dispatch door_closed or gear_extended or gear_retracted]->s0 {
					door_closed?(dc);
					gear_extended?(ge);
					gear_retracted?(gr);
					maneuvring!(not dc and not ge and not gr);
					if (not dc and not ge and not gr) { -- on n'a qu'un seul état à la fois
						locked_down!(false);
						error!(false)
					}
					end if
				};
				
				-- reveillé si porte fermée, roue retractée, on n'est ni en maneuvring ni en locked_down
				s0-[on dispatch door_closed or gear_retracted]->s0 {
					door_closed?(dc);
					gear_retracted?(gr);
					if (dc and gr) { -- on n'a qu'un seul état à la fois
						locked_down!(false);
						maneuvring!(false);
						error!(false)
					}
					end if
				};
				
		**};
	end pilote_interface_thread.pilote_interface;
	
end gears_system;
